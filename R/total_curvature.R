#' Calculate total curvature from polynomial functions
#' fitted to landmarked specimens.
#'
#' Calculates point-wise
#' curvature along bounded polynomials fitted to curved
#' specimens. Polynomials are fitted to landmarked
#' specimens using package \code{Momocs}.
#'
#'
#' @param Momocs_poly a polynomial \code{list} object
#' generated by \code{Momocs:::npoly.default()} or
#' \code{Momocs:::opoly.default()}. This function cannot yet
#' handle \code{OpnCoe} objects created by e.g. \code{Momocs:::npoly.Opn()}.
#'
#' @param x_range the lower and upper x-value bounds to
#' calculate curvature. These are named 'baselines'
#' in \code{Momocs} polynomial objects.
#'
#' @param subdiv number of subdivisions made
#' within \code{x_range}. Curvature is calculated at every
#' subdivision and summed to compute total curvature.
#' Default is 1000. The same number of subdivisions will be
#' applied to all curves, regardless of arclength.
#'
#' @return a list. The first element contains point-wise curvature. Units are
#' degrees per unit length. These values are useful for inspecting local
#' curvature features. The second element is total curvature. Units are radians.
#' Since arclength (ie specimen size) does not affect
#' the number of times point-wise curvature is computed (see \code{subdiv}),
#' there is no need to divide total curvature by arclength to adjust for specimen size.
#'
#'
#' @examples
#'
#' library(Momocs)
#'
#' x <- 1:10
#' y <- x^2
#'
#' # a fictional landmark dataset
#' mdat <- matrix(c(x,y), nrow=10, ncol=2)
#'
#' # fit second-order polynomial to landmarks
#' my_poly <- Momocs::npoly(mdat, 2)
#'
#' # extract x bounds from Momocs polynomial object
#' x_range <- c(my_poly$baseline1[[1]], my_poly$baseline2[[1]])
#'
#' # compute point-wise curvature 100 times
#' total_curvature(my_poly, x_range, 100)
#'
#'
#' @importFrom dplyr %>%
#' @importFrom stats deriv3
#' @importFrom stats uniroot
#' @importFrom pracma arclength
#'
#' @export



total_curvature <- function(Momocs_poly, x_range, subdiv = 1000, param = FALSE) {

  # is.atomic checks that x_range cannot be a list or
  # expression
  stopifnot(is.atomic(x_range))
  if (!is.numeric(x_range))
    stop("'x_range' must be a numeric vector.")
  if (length(x_range) != 2)
    stop("'x_range' must be a vector of length two.")

  # calculates the difference between x1 and x2 to
  # ensure >0
  if (diff(x_range) < 0)
    stop("please reorder 'x_range'.")
  if (!inherits(Momocs_poly, "list"))
    stop("'Momocs_poly' must be a polynomial object (list) of morphometric coefficients,
  i.e. an list object generated by Momocs::npoly or Momocs::opoly.
  See: '?Momocs::npoly'.")
  if (!is.numeric(subdiv))
    stop("subdiv must be a numeric vector of length 1.")
  if (length(subdiv) != 1)
    stop("subdiv must be a numeric vector of length 1.")


  # compute derivates by curvr::as_expression() and
  # deriv3()
  express_poly <- as_expression(Momocs_poly)
  dfun <- stats::deriv3(express_poly, "x", func = TRUE) %>%
    unname()

  # ensure function is not a straight line
  if (attr(dfun(x_range[1]), "gradient") == attr(dfun(x_range[2]),
                                                 "gradient"))
    stop("functions should not be linear - inputs should be polynomials.")


  # function runs faster if not parameterized by arclength
  if (param == FALSE) {
    x <- seq(from = x_range[1], to = x_range[2], by = abs(x_range[2] - x_range[1])/subdiv)
  } else {

  # convert Momocs list objects to t-parameterized
  # polynomials for pracma::arclength()
  param_poly <- parameterize(Momocs_poly)

  # create vector of subdivisions to calculate arclength parameter
  iter <- seq(0, 1, by = 1/subdiv)
  arcfun_list <- list()

  # arc length of t-parameterized function
  arc <- pracma::arclength(param_poly, x_range[1],
                         x_range[2])$length

  # for every fraction of arclength, b*i, create a
  # function(u) with an unknown x-coordinate, u
  for (i in seq_along(iter)) {
    arcfun_list[[i]] <- local({
      arc_sub <- iter[i] * arc
      function(u) pracma::arclength(param_poly,
                                    x_range[1], u)$length - arc_sub
    })
  }

  # Solve for u value that gives arclength=b*i
  # root-finding function
  root_find <- function(x) stats::uniroot(x, x_range)$root


  # parameterize polynomial function by arc length
  x <- sapply(arcfun_list, root_find)

}
  # The tangents (first derv) of the x_n components, dfun() is defined above
  # The gradient matrix has elements that are the y value
  # computed from first deriv of y=f(x)
  gr <- attr(dfun(x), "gradient")

  # The hessian matrix has elements that are the y values
  # of the second deriv of y=f(x)
  he <- attr(dfun(x), "hessian")[, , "x"]

  # has n=subdiv measurements of k
  # convert from rad to degrees
  k <- (abs(he)/(1 + gr^2)^(3/2))

  # add all measurements of k, rescale depending on #of subdivisions
  f0 <- as_function(Momocs_poly)

  k_fun <- function(x) {

      f1 <- Deriv::Deriv(f0)
      f2 <- Deriv::Deriv(f1)
      ((f2(x)) / ((1 + (f1(x)^2))^1.5)) *
        (sqrt(1+(f1(x))^2))
  }

  k_total <- integrate(k_fun, lower = x_range[1], upper = x_range[2])$value

  # define output
  return(k_total)
}
