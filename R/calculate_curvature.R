#' Calculate total curvature from polynomial functions
#' fitted to landmarked specimens.
#'
#' Calculates point-wise
#' curvature along bounded polynomials fitted to curved
#' specimens. Polynomials are fitted to landmarked
#' specimens using package \code{Momocs}.
#'
#' @param x_range the lower and upper x-values bounds to
#' calculate curvature. These are named 'baselines'
#' in Momocs polynomial objects.
#'
#' @param Momocs_poly a polynomial OpnCoe object (list)
#' generated by \code{Momocs::npoly()} or
#' \code{Momocs::opoly()}
#'
#' @param subdiv number of subdivisions made
#' within \code{x_range}. Curvature is calculated at every
#' subdivision and summed to compute total curvature.
#' Default is 1000.
#'
#' @return a number: total curvature. Units are
#' degrees. Divide by arclength for comparisons
#' between specimens.
#'
#' @examples
#'
#' library(Momocs)
#'
#' x <- 1:10
#' y <- x^2
#'
#' #a fictional landmark dataset
#' mdat <- matrix(c(x,y), nrow=10, ncol=2)
#'
#' my_poly <- Momocs::npoly(mdat, 2)
#'
#' #extract x bounds from Momocs polynomial object
#' x_range <- c(my_poly$baseline1[[1]], my_poly$baseline2[[1]])
#'
#' totalK(x_range, my_poly, 100)
#'
#'
#' @importFrom dplyr %>%
#' @importFrom stats deriv3
#' @importFrom stats uniroot
#' @export



totalK <- function(x_range, Momocs_poly, subdiv) {

  # is.atomic checks that x_range cannot be a list or
  # expression
  stopifnot(is.atomic(x_range))
  if (!is.numeric(x_range))
    stop("'x_range' must be a numeric vector.")
  if (length(x_range) != 2)
    stop("'x_range' must be a vector of length two.")

  # calculates the difference between x1 and x2 to
  # ensure it's >0
  if (diff(x_range) < 0)
    stop("please reorder 'x_range'.")
  if (!inherits(Momocs_poly, "list"))
    stop("'Momocs_poly' must be a polynomial object (list) of morphometric coefficients,
  i.e. an 'OpnCoe' object generated by Momocs::npoly or Momocs::opoly.
  See: '?Momocs::OpnCoe'.")
  if (!is.numeric(subdiv))
    stop("subdiv must be a numeric vector of length 1.")
  if (length(subdiv) != 1)
    stop("subdiv must be a numeric vector of length 1.")


  # compute derivates by curvy::express() and
  # deriv3()
  exp_poly <- express(Momocs_poly)
  dfun <- deriv3(exp_poly, "x", func = TRUE) %>%
    unname()

  # make sure function is not a straight line
  if (attr(dfun(x_range[1]), "gradient") == attr(dfun(x_range[2]),
                                                 "gradient"))
    stop("functions should not be linear - inputs should be polynomials.")


  # convert Momocs OpnCoe objects to t-parameterized
  # polynomials for pracma::arclength()

  param_poly <- param(Momocs_poly)

  #create vector of subdivisions to calculate arclength parameter
  iter <- seq(0, 1, by = 1/subdiv)
  arcfun_list <- list()

  #arc length of t-parameterized function
  b <- pracma::arclength(param_poly, x_range[1],
                         x_range[2])$length

  # for every fraction of arclength, b*i, create a
  # function(u) with an unknown x-coordinate, u
  for (i in seq_along(iter)) {
    arcfun_list[[i]] <- local({
      b_sub <- iter[i] * b
      function(u) pracma::arclength(param_poly,
                                    x_range[1], u)$length - b_sub
    })
  }

  # Solve for u value that gives arclength=b*i
  root_find <- function(x) uniroot(x, x_range)$root  #root-finding function

  # parameterize polynomial function by arc length
  x <- sapply(arcfun_list, root_find)  #find roots for a list of

  # The tangents (first derv) of the x_n components, dfun() is defined above
  # The gradient matrix has elements that are the first deriv of a function
  gr <- attr(dfun(x), "gradient")

  # The hessian matrix has elements that are the second deriv of a function
  he <- attr(dfun(x), "hessian")[, , "x"]

  #has n=subdiv measurements of k
  k <- abs(he)/(1 + gr^2)^(3/2)

  #add all measurements of k, rescale depending on #of subdivisions,
  #and convert from rad to degrees
  k_total <- (sum(k)/subdiv) * (180/pi)
}
