% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/curvature_spline.R
\name{curvature_spline}
\alias{curvature_spline}
\title{Calculate total curvature from smoothing or interpolating splines.}
\usage{
curvature_spline(landmark_matrix, x_range, type = "smooth")
}
\arguments{
\item{landmark_matrix}{is a \code{matrix} object with \code{[,1]}
containing the x landmark coordinates and \code{[,2]} containing
the y landmark coordinates.}

\item{x_range}{the lower and upper x-value bounds to
calculate curvature. Concatenate the lower and upper bounds using
\code{c()}, E.g. for lower = 1 and upper = 10, type \code{c(1,10)}.}

\item{type}{either 'ip' for an interpolating spline or 'smooth' for a
smoothing spline. Uses \code{stats::spline()} or \code{stats::smooth.spline()}, respectively,
for curve fitting and estimating the derivatives. Default is \code{type = 'smooth'}.
See: ?spline and ?smooth.spline for details.}
}
\value{
a `list` with two named elements. `$Ktot` is the total curvature in radians. `$Ki` is a numeric vector of local curvature values.
}
\description{
Calculate total curvature from smoothing or interpolating splines.
}
\examples{

# a landmark matrix describing a segment of the unit circle#'
x <- seq(0, 1, by = 0.01)
y <- sqrt(1-x^2)
mdat <- matrix(c(x, y), nrow = 101, ncol = 2)

# total curvature between x=0 and x=sqrt(2)/2 should be approximately pi/4
abs(curvature_spline(mdat, c(0, sqrt(2)/2), type='smooth')$Ktot)

}
